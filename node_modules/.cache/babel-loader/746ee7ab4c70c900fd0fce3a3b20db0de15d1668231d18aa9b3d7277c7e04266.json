{"ast":null,"code":"import { camelize, wrapInArray } from './helpers';\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/\n};\nfunction parseStyle(style) {\n  const styleMap = {};\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp);\n    key = key.trim();\n    if (!key) {\n      continue;\n    } // May be undefined if the `key: value` pair is incomplete.\n\n    if (typeof val === 'string') {\n      val = val.trim();\n    }\n    styleMap[camelize(key)] = val;\n  }\n  return styleMap;\n}\nexport default function mergeData() {\n  const mergeTarget = {};\n  let i = arguments.length;\n  let prop; // Allow for variadic argument length.\n\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop]);\n          }\n          break;\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop]);\n          }\n          break;\n        // Space delimited string concatenation strategy\n\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break;\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = '';\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' ';\n          }\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop]);\n          }\n          break;\n        // Object merge strategy\n\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break;\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n          mergeTarget[prop] = {\n            ...arguments[i][prop],\n            ...mergeTarget[prop]\n          };\n          break;\n        // Reassignment strategy (no merge)\n\n        default:\n          // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n      }\n    }\n  }\n  return mergeTarget;\n}\nexport function mergeStyles(target, source) {\n  if (!target) return source;\n  if (!source) return target;\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target);\n  return target.concat(typeof source === 'string' ? parseStyle(source) : source);\n}\nexport function mergeClasses(target, source) {\n  if (!source) return target;\n  if (!target) return source;\n  return target ? wrapInArray(target).concat(source) : source;\n}\nexport function mergeListeners(...args) {\n  if (!args[0]) return args[1];\n  if (!args[1]) return args[0];\n  const dest = {};\n  for (let i = 2; i--;) {\n    const arg = args[i];\n    for (const event in arg) {\n      if (!arg[event]) continue;\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = [].concat(arg[event], dest[event]);\n      } else {\n        // Straight assign.\n        dest[event] = arg[event];\n      }\n    }\n  }\n  return dest;\n}","map":{"version":3,"names":["camelize","wrapInArray","pattern","styleList","styleProp","parseStyle","style","styleMap","s","split","key","val","trim","mergeData","mergeTarget","i","arguments","length","prop","Object","keys","mergeClasses","mergeStyles","undefined","mergeListeners","target","source","concat","args","dest","arg","event"],"sources":["C:/Users/emanuel.bessa/Desktop/projeto-portfolio/portfolio/node_modules/vuetify/lib/util/mergeData.js"],"sourcesContent":["import { camelize, wrapInArray } from './helpers';\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/\n};\n\nfunction parseStyle(style) {\n  const styleMap = {};\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp);\n    key = key.trim();\n\n    if (!key) {\n      continue;\n    } // May be undefined if the `key: value` pair is incomplete.\n\n\n    if (typeof val === 'string') {\n      val = val.trim();\n    }\n\n    styleMap[camelize(key)] = val;\n  }\n\n  return styleMap;\n}\n\nexport default function mergeData() {\n  const mergeTarget = {};\n  let i = arguments.length;\n  let prop; // Allow for variadic argument length.\n\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n        // Space delimited string concatenation strategy\n\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = '';\n          }\n\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' ';\n          }\n\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n        // Object merge strategy\n\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          mergeTarget[prop] = { ...arguments[i][prop],\n            ...mergeTarget[prop]\n          };\n          break;\n        // Reassignment strategy (no merge)\n\n        default:\n          // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n\n      }\n    }\n  }\n\n  return mergeTarget;\n}\nexport function mergeStyles(target, source) {\n  if (!target) return source;\n  if (!source) return target;\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target);\n  return target.concat(typeof source === 'string' ? parseStyle(source) : source);\n}\nexport function mergeClasses(target, source) {\n  if (!source) return target;\n  if (!target) return source;\n  return target ? wrapInArray(target).concat(source) : source;\n}\nexport function mergeListeners(...args) {\n  if (!args[0]) return args[1];\n  if (!args[1]) return args[0];\n  const dest = {};\n\n  for (let i = 2; i--;) {\n    const arg = args[i];\n\n    for (const event in arg) {\n      if (!arg[event]) continue;\n\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = [].concat(arg[event], dest[event]);\n      } else {\n        // Straight assign.\n        dest[event] = arg[event];\n      }\n    }\n  }\n\n  return dest;\n}\n//# sourceMappingURL=mergeData.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}